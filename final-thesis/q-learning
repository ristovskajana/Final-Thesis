import pygame
import os
import random
import numpy as np

pygame.init()

clock = pygame.time.Clock()
fps = 60

screen_width = 864
screen_height = 936

screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption('Flappy Bird')

# LOADING ALL IMAGES
background_img = pygame.image.load('img/bg.png')
ground_img = pygame.image.load('img/ground.png')
button_img = pygame.image.load('img/restart.png')

def draw_text(text, font, color, x, y):
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

def reset_game():
    pipe_group.empty()
    flappy.rect.x = 100
    flappy.rect.y = int(screen_height/2)
    score = 0
    return score

# Number of episodes to run
num_episodes = 10000

# List to store cumulative rewards for each episode
episode_rewards = []

# Q-learning parameters
epsilon = 0.3
epsilon_decay = 0.001
epsilon_min = 0.1
alpha = 0.8
gamma = 0.3

num_discrete_states = 375


num_actions = 2  # Two possible actions: 0 for not jumping, 1 for jumping

# Initialize Q-table
discretized_states = np.zeros(num_discrete_states)
q_table = np.zeros((num_discrete_states, num_actions), dtype= float)

combinations = []
for x in range(15):
    for y in range(25):
        combinations.append((x, y))

integer_array = list(range(375))

mapping = dict(zip(combinations, integer_array))


# Initialize episode records
episode_rewards = []
episode_states = []  # Initialize episode states list
episode_actions = []


# Function to update Q-table based on observed reward and next state
def update_q_table(state, action, reward, next_state):
    max_q = max(q_table[next_state].values()) if q_table[next_state] else 0
    q_table[state][action] += alpha * (reward + gamma * max_q - q_table[state][action])

def discretize_horizontal(value):
    bins = np.linspace(0, 700, 14)
    discretized_value = np.digitize(value, bins)
    return discretized_value # Subtract 1 to convert bin index to range 0-14

def discretize_vertical(value):
    bins = np.linspace(0, 1200, 24)  # Shift the bins to positive range
    shifted_value = value + 750  # Shift the value to positive range
    discretized_value = np.digitize(shifted_value, bins)
    return discretized_value # Subtract 1 to convert bin index to range 0-14


# 726

# GAME VARIABLES
font = pygame.font.SysFont('Bauhaus 93', 60)
white = (255, 255, 255)
scroll_ground = 0
scroll_speed = 4
flying = False
dead = False
pipe_gap = 170
pipe_frequency = 1500
last_pipe = pygame.time.get_ticks() - pipe_frequency
score = 0
pass_pipe = False
last_pipe_time = pygame.time.get_ticks() 
gravity = 0.5

# Variable to store the high score so far
high_score = 0  

class Bird(pygame.sprite.Sprite):
    def __init__(self, x, y):
        pygame.sprite.Sprite.__init__(self)
        self.images = []
        self.index = 0
        self.counter = 0
        for num in range(1, 4):
            bird_img = pygame.image.load(f'img/bird{num}.png')
            self.images.append(bird_img)
        self.image = self.images[self.index]
        self.rect = self.image.get_rect()
        self.rect.center = [x, y]

        # Initialize Q-learning parameters
        self.learning_rate = alpha
        self.discount_factor = gamma
        self.epsilon = epsilon
        self.epsilon_decay = epsilon_decay
        self.epsilon_min = epsilon_min

        # Initialize state
        self.state = None
        self.last_state = None
        self.action = None
        self.last_action = None

        # Initialize velocity
        self.vel_y = 0


    def update(self):
        if flying == True:
            self.vel_y += gravity
            if self.vel_y > 8:
                self.vel_y = 8
            if self.rect.bottom < 768:
                self.rect.y += int(self.vel_y)
        else:
            if self.rect.y < 0:
                self.rect.y = 0

        # Update Q-learning state
        self.update_state()

        jump_value = q_table[self.state][1] # Value if we jump
        # print( "For jump ",  q_table[self.state][1])
        no_jump_value = q_table[self.state][0]  # Value if we don't jump
        # print( "For not jump ",  q_table[self.state][0])

        if (jump_value > no_jump_value).any():
            self.action = 1  # Action to jump
        else:
            self.action = 0  # Action not to jump

        # Update last state and last action
        self.last_state = self.state
        self.last_action = self.action

        # Update index to animate bird
        self.counter += 1
        flap_cooldown = 5
        if self.counter > flap_cooldown:
            self.counter = 0
            self.index += 1
            if self.index >= len(self.images):
                self.index = 0
        self.image = self.images[self.index]

        # Rotate the bird
        self.image = pygame.transform.rotate(self.images[self.index], self.vel_y * -2)
        # self.rect = self.image.get_rect(center=(self.rect.centerx, self.rect.centery))
        self.rect.x = 100  # Set the desired X position here

    def jump(self):
        self.vel_y = -10

    def not_jump(self):
        self.vel_y = +0.5

    def update_state(self):
        horizontal_distance = self.horizontal_distance()
        vertical_distance = self.vertical_distance()
        # print("Horiz: ", horizontal_distance)
        # print("Ver: ", vertical_distance)

        discrete_horizontal_distance = discretize_horizontal(horizontal_distance)
        discrete_vertical_distance = discretize_vertical(vertical_distance)

        self.state = mapping[(discrete_horizontal_distance, discrete_vertical_distance)]
        # print("State:", self.state, " horizontal: ", discrete_horizontal_distance, " verical: ", discrete_vertical_distance)

    def get_closest_lower_pipe(self):
        closest_lower_pipe = None
        closest_lower_pipe_dist = float('inf')
        for pipe in pipe_group:
            if pipe.position == 1: # retirve only the lower pipes
                if pipe.rect.x > self.rect.centerx:
                    distance = pipe.rect.x - self.rect.centerx
                    if distance < closest_lower_pipe_dist:
                        closest_lower_pipe_dist = distance
                        closest_lower_pipe = pipe
        return closest_lower_pipe

    
    def horizontal_distance(self):
        closest_lower_pipe = self.get_closest_lower_pipe()
        if closest_lower_pipe is not None:
            distance = closest_lower_pipe.rect.left - self.rect.right
            return distance
        else:
            return float('inf')

    def vertical_distance(self):
        closest_lower_pipe = self.get_closest_lower_pipe()
        if closest_lower_pipe is not None:
            y_distance = screen_height - self.rect.bottom
            distance = y_distance - (closest_lower_pipe.rect.top * (-1))
            # print("Pipes top: ", closest_lower_pipe.rect.top * (-1))
            # print("Bird bottom : ", y_distance)
            return distance
        else:
            return float('inf')
    
    def choose_action(self, q_table, state):
        jump_value = q_table[self.state][1]  # Value if we jump
        no_jump_value = q_table[self.state][0]   # Value if we don't jump

        if (jump_value > no_jump_value).any():
            return 1  # Action to jump
        else:
            return 0  # Action not to jump

    def update_q_table(self, state, action, reward, next_state):
        max_q = max(q_table[next_state]) if q_table[next_state].size > 0 else 0
        q_table[state][action] += self.learning_rate * (reward + self.discount_factor * max_q - q_table[state][action])


        
# Creating bird class
bird_group = pygame.sprite.Group()
flappy = Bird(100, int(screen_height/2))
bird_group.add(flappy)

class Pipe(pygame.sprite.Sprite):
    def __init__(self, x, y, position):
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load('img/pipe.png')
        self.rect = self.image.get_rect()
        self.passed = False  # Initialize the 'passed' attribute to False
        # position variable determines if the pipe is coming from the bottom or top
        self.position = position  

        if position == 1:
            self.image = pygame.transform.flip(self.image, False, True)
            self.rect.bottomleft = [x, y - int(pipe_gap/2)]
        if position == -1:
            self.rect.topleft = [x, y + int(pipe_gap/2)]

    def update(self):
        self.rect.x -= scroll_speed
        if self.rect.right < 0:
            self.kill()

# Create pipe group
pipe_group = pygame.sprite.Group()

# Load Q-table if it exists
q_table = np.load('q_table.npy') if os.path.isfile('q_table.npy') else q_table

run = True
while run:
    clock.tick(fps)
    screen.blit(background_img, (0, 0))

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                # Ignore spacebar press event
                pass

    # Update and draw pipes
    pipe_group.draw(screen)
    pipe_group.update()

    # Draw ground
    scroll_ground -= scroll_speed
    if abs(scroll_ground) > 35:
        scroll_ground = 0
    screen.blit(ground_img, (scroll_ground, 768))

    # Draw and update birds
    bird_group.draw(screen)
    bird_group.update()

    current_time = pygame.time.get_ticks()
    if current_time - last_pipe >= pipe_frequency:
        pipe_x = screen_width
        pipe_y = random.randint(300, 600)  # Adjust the range as needed
        top_pipe = Pipe(pipe_x, pipe_y, -1)
        bottom_pipe = Pipe(pipe_x, pipe_y, 1)
        pipe_group.add(top_pipe, bottom_pipe)
        last_pipe = current_time

    # Check collision with pipes
    if pygame.sprite.groupcollide(bird_group, pipe_group, False, False) or flappy.rect.top < 0 :
        dead = True

    # check if the bird has hit the ground
    if flappy.rect.bottom >= 768:
        dead = True
        flying = False

    if not dead:
        # Check if bird has passed the pipe
        for pipe in pipe_group:
            if pipe.rect.right < flappy.rect.left and not pipe.passed:
                pipe.passed = True
                pass_pipe = True

        # Update score
        if pass_pipe:
            score += 1
            pass_pipe = False

            if score > high_score:
                high_score = score

        # Update Q-learning state and choose action
        flappy.update_state()
        action = flappy.choose_action(q_table, flappy.state)

        # Apply action
        if action == 1:
            flying = True
            flappy.jump()
        else:
            flying = True
            flappy.not_jump()

        # Choose action
        flappy.last_action = action
        flappy.action = action

        # Update Q-table
        if flappy.last_state is not None and flappy.last_action is not None:
            reward = 1 if pass_pipe else -1000  # Assign reward based on passing the pipe or hitting an obstacle
            next_state = flappy.state  # Update next state
            flappy.update_q_table(flappy.last_state, flappy.last_action, reward, next_state)  # Update the Q-table using the flappy object

        # Update last state and last action
        flappy.last_state = flappy.state

        # Draw score
        draw_text(str(score), font, white, int(screen_width / 2), 20)

    # Check if the bird has hit the ground
    if flappy.rect.y > 768 or dead:
        dead = False
        flying = False
        episode_rewards.append(score)
        print("Q-table:")
        print(q_table)  # Print the Q-table
        score = reset_game()

        # Decay epsilon
        if epsilon > epsilon_min:
            epsilon *= epsilon_decay

        # Update Q-table using episode rewards
        for i in range(len(episode_rewards) - 1, -1, -1):
            reward = episode_rewards[i]
            state = episode_states[i]
            action = episode_actions[i]
            next_state = episode_states[i + 1] if i + 1 < len(episode_states) else None
            if next_state is not None:
                flappy.update_q_table(flappy.last_state, flappy.last_action, reward, next_state)  # Update the Q-table using the flappy object

        # Clear episode records
        episode_rewards = []
        episode_states = []
        episode_actions = []

        # Save the Q-table after each episode
        np.save('q_table.npy', q_table)

        # Load Q-table for the next episode
        q_table = np.load('q_table.npy')

        # Print dimensions of the Q-table
        print("Q-table dimensions:", q_table.shape)
        # Print high score
        print("High Score:", high_score)




    # Append current state and action to episode records
    episode_states.append(flappy.state)
    episode_actions.append(action)

    pygame.display.update()

pygame.quit()